{-# LANGUAGE CPP             #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TemplateHaskell #-}
{-# OPTIONS_GHC -fno-warn-orphans #-}
-- |
-- Module      : Data.Array.Accelerate.LLVM.Native.Plugin
-- Copyright   : [2017] Trevor L. McDonell
-- License     : BSD3
--
-- Maintainer  : Trevor L. McDonell <tmcdonell@cse.unsw.edu.au>
-- Stability   : experimental
-- Portability : non-portable (GHC extensions)
--
-- This module provides a GHC plugin to help support ahead-of-time compilation
-- for the accelerate-llvm-native backend. In particular, it tells GHC about the
-- additional object files generated by Accelerate which must be linked into the
-- final executable.
--

module Data.Array.Accelerate.LLVM.Native.Plugin (

  plugin,

) where

import GhcPlugins
import Linker
import SysTools

import Control.Monad
import Data.IORef
import Data.List
import Data.Serialize
import System.Directory
import System.FilePath
import qualified Data.ByteString                                    as B
import qualified Data.Map                                           as Map

import Data.Array.Accelerate.Error
import Data.Array.Accelerate.LLVM.Native.Plugin.Annotation


plugin :: Plugin
plugin = defaultPlugin
  { installCoreToDos = install
  }

install :: [CommandLineOption] -> [CoreToDo] -> CoreM [CoreToDo]
install _ rest = do
#if __GLASGOW_HASKELL__ < 802
  reinitializeGlobals
#endif
  let this (CoreDoPluginPass "accelerate-llvm-native" _) = True
      this _                                             = False
  --
  return $ CoreDoPluginPass "accelerate-llvm-native" pass : filter (not . this) rest

pass :: ModGuts -> CoreM ModGuts
pass guts = do
  -- Determine the current build environment
  --
  hscEnv   <- getHscEnv
  dynFlags <- getDynFlags
  this     <- getModule

  -- Gather annotations for the extra object files which must be supplied to the
  -- linker in order to complete the current module.
  --
  paths   <- nub . concat <$> mapM (objectPaths guts) (mg_binds guts)

  when (not (null paths))
    $ debugTraceMsg
    $ hang (text "Data.Array.Accelerate.LLVM.Native.Plugin: linking module" <+> quotes (pprModule this) <+> text "with:") 2 (vcat (map text paths))

  -- The linking method depends on the current build target
  --
  case hscTarget dynFlags of
    HscNothing     -> return ()
    HscInterpreted ->
      -- We are in interactive mode (ghci)
      --
      when (not (null paths)) . liftIO $ do
        let opts  = ldInputs dynFlags
            objs  = map optionOfPath paths
        --
        linkCmdLineLibs
#if __GLASGOW_HASKELL__ < 800
               $                       dynFlags { ldInputs = opts ++ objs }
#else
               $ hscEnv { hsc_dflags = dynFlags { ldInputs = opts ++ objs }}
#endif

    -- We are building to object code.
    --
    -- Because of separate compilation, we will only encounter the annotation
    -- pragmas on files which have changed between invocations. This applies to
    -- both @ghc --make@ as well as the separate compile/link phases of building
    -- with @cabal@ (and @stack@). Note that whenever _any_ file is updated we
    -- must make sure that the linker options contains the complete list of
    -- objects required to build the entire project.
    --
    _ -> liftIO $ do
      let omp     = objectMapPath dynFlags </> "accelerate-llvm-native-ld-tmp"
          handle  = either ($internalError "plugin" "unable to read cache file") id

      exists  <- doesFileExist omp
      objMap  <- if not exists
                   then return (Map.singleton this paths)
                   else do
                     f <- B.readFile omp
                     return $ Map.insert this paths (handle (decode f))
      B.writeFile omp (encode objMap)

      let allPaths  = nub (concat (Map.elems objMap))
          allObjs   = map optionOfPath allPaths

      -- Make sure the linker flags are up-to-date.
      --
      when (not (isNoLink (ghcLink dynFlags))) $ do
        linker_info <- getLinkerInfo dynFlags
        writeIORef (rtldInfo dynFlags)
          $ Just
          $ case linker_info of
              GnuLD     opts -> GnuLD     (nub (opts ++ allObjs))
              GnuGold   opts -> GnuGold   (nub (opts ++ allObjs))
              DarwinLD  opts -> DarwinLD  (nub (opts ++ allObjs))
              SolarisLD opts -> SolarisLD (nub (opts ++ allObjs))
#if __GLASGOW_HASKELL__ >= 800
              AixLD     opts -> AixLD     (nub (opts ++ allObjs))
#endif
              UnknownLD      -> UnknownLD  -- no linking performed?

      return ()

  return guts

objectPaths :: ModGuts -> CoreBind -> CoreM [FilePath]
objectPaths guts (NonRec b _) = objectAnns guts b
objectPaths guts (Rec bs)     = concat <$> mapM (objectAnns guts) (map fst bs)

objectAnns :: ModGuts -> CoreBndr -> CoreM [FilePath]
objectAnns guts bndr = do
  anns  <- getAnnotations deserializeWithData guts
  return [ path | Object path <- lookupWithDefaultUFM anns [] (varUnique bndr) ]

objectMapPath :: DynFlags -> FilePath
objectMapPath DynFlags{..}
  | Just p <- objectDir = p
  | Just p <- dumpDir   = p
  | otherwise           = "."

optionOfPath :: FilePath -> Option
optionOfPath = FileOption []


instance Serialize Module where
  put (Module p n) = put p >> put n
  get = do
    p <- get
    n <- get
    return (Module p n)

instance Serialize UnitId where
  put u = put (unitIdString u)
  get   = stringToUnitId <$> get

instance Serialize ModuleName where
  put m = put (moduleNameString m)
  get   = mkModuleName <$> get

