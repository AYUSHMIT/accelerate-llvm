{-# LANGUAGE CPP                #-}
{-# LANGUAGE DeriveDataTypeable #-}
-- |
-- Module      : Data.Array.Accelerate.LLVM.Native.Plugin
-- Copyright   : [2017] Trevor L. McDonell
-- License     : BSD3
--
-- Maintainer  : Trevor L. McDonell <tmcdonell@cse.unsw.edu.au>
-- Stability   : experimental
-- Portability : non-portable (GHC extensions)
--
-- This module provides a GHC plugin to help support ahead-of-time compilation
-- for the accelerate-llvm-native backend. In particular, it tells GHC about the
-- additional object files generated by Accelerate which must be linked into the
-- final executable.
--

module Data.Array.Accelerate.LLVM.Native.Plugin (

  plugin,
  Object(..),

) where

import GhcPlugins
import Linker
import SysTools

import Control.Applicative
import Control.Monad
import Data.Data
import Data.IORef
import Data.List


data Object = Object FilePath
  deriving (Show, Data, Typeable)

plugin :: Plugin
plugin = defaultPlugin
  { installCoreToDos = install
  }

install :: [CommandLineOption] -> [CoreToDo] -> CoreM [CoreToDo]
install args rest = do
#if __GLASGOW_HASKELL__ < 802
  reinitializeGlobals
#endif
  let interactive = "interactive" `elem` args
      --
      this (CoreDoPluginPass "accelerate-llvm-native" _) = True
      this _                                             = False
  --
  return $ CoreDoPluginPass "accelerate-llvm-native" (pass interactive) : filter (not . this) rest

pass :: Bool -> ModGuts -> CoreM ModGuts
pass interactive guts = do
  paths   <- nub . concat <$> mapM (objectPaths guts) (mg_binds guts)
  objects <- return $ map (FileOption []) paths

  when (not (null paths)) $
    debugTraceMsg $ vcat $ map text $ "Data.Array.Accelerate.LLVM.Native.Plugin linking with:" : paths

  -- We need to pass the extra object files along differently depending on
  -- whether we are in interactive (ghci) or normal mode.
  if interactive
    then do
      hsc_env <- getHscEnv
      let dyn_flags = hsc_dflags hsc_env
          ld_inputs = ldInputs dyn_flags
      liftIO $ linkCmdLineLibs
#if __GLASGOW_HASKELL__ < 800
             $                        dyn_flags { ldInputs = ld_inputs ++ objects }
#else
             $ hsc_env { hsc_dflags = dyn_flags { ldInputs = ld_inputs ++ objects }}
#endif

    else do
      dyn_flags   <- getDynFlags
      linker_info <- liftIO $ getLinkerInfo dyn_flags
      liftIO $ writeIORef (rtldInfo dyn_flags)
             $ Just
             $ case linker_info of
                 GnuLD     opts -> GnuLD     (opts ++ objects)
                 GnuGold   opts -> GnuGold   (opts ++ objects)
                 DarwinLD  opts -> DarwinLD  (opts ++ objects)
                 SolarisLD opts -> SolarisLD (opts ++ objects)
#if __GLASGOW_HASKELL__ >= 800
                 AixLD     opts -> AixLD     (opts ++ objects)
#endif
                 UnknownLD      -> UnknownLD  -- no linking performed?

  return guts

objectPaths :: ModGuts -> CoreBind -> CoreM [FilePath]
objectPaths guts (NonRec b _) = objectAnns guts b
objectPaths guts (Rec bs)     = concat <$> mapM (objectAnns guts) (map fst bs)

objectAnns :: ModGuts -> CoreBndr -> CoreM [FilePath]
objectAnns guts bndr = do
  anns  <- getAnnotations deserializeWithData guts
  return [ path | Object path <- lookupWithDefaultUFM anns [] (varUnique bndr) ]

